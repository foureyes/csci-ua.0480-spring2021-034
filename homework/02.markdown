---
layout: homework
title: CSCI-UA.0480 - Homework #2
---

<div class="panel panel-default">
  <div class="panel-heading">Homework #2</div>
  <div class="panel-body" markdown="block">

# Higher Order Functions: Exercises and Processing Data - Due __Feb 16th, by 11PM__

## Overview

### Description

__hoffy.js__ - Write a series of functions that demonstrate the use of the rest operator (or call/apply), and higher order functions

__drawing.js__ - Create classes that represent rectangles, text, and a container to hold a _drawing_

__disney.js__ and __report.js__ - Print out a report analyzing Walt Disney movies dataset.


### Submission Process

You will be given access to a private repository on GitHub. It will contain unit tests, stub files for your code, a `package.json` and a `.eslintrc`

* The final version of your assignment should be in GitHub.
* __Push__ your changes to the homework repository on GitHub.

### Minimum number of commits

As you write your code, make sure that you make at least four commits total (more commits are better; if you can, try to commit per feature added).

* the commits should be meaningful (that is, do not just add a newline, commit and push to make up the requirements for commits).
* make sure your commit messages describe the changes in the commit; for example:
	* add solutions to problem 2 and 3 of part 1
	* fix a bug that prevented reading of csv file

		```
git add <files>
git commit -m 'your commit message'
```
* push your code frequently
		```
git push
```

## Part 1 - Setup and Exercises

For this homework, you'll have files available in your repository, so you'll be cloning first.

The solutions to the following problems can go in the same file - __src/hoffy.js__:

### Setup

1. go to your github account...
2. find your repository: NetID-homework02 (note... this __should be your NetID__)
3. use the appropriate URL to run git clone

<pre><code data-trim contenteditable>git clone [YOUR REPO URL]</code></pre>

### Background Info

Implement functions that use JavaScript features such as:

* the rest operator
* the spread operator
* functions as arguments
* functions as return values
* decorators
* optionally call/apply/bind
* optionally arrow functions
* Array methods: 'filter', 'map', 'reduce'

__No type checking of incoming arguments is required unless explicitly mentioned in instructions__ 

__Do not use__:

* `while` loops
* `for` loops
* `for ... in` loops
* `for ... of` loops
* `forEach` method 

__There will a small (-2) penalty every time one is used__. (Homework is 100 points total)


### Steps

1. prep...
    * create a `.gitignore` to ignore node_modules
	* create a `package.json` by using `npm init`
    * make sure that `mocha`, `chai`, and `eslint` are still installed (similar to previous assignment)

		```
npm install -g mocha
npm install --save-dev eslint
npm install --save-dev chai
npm install --save-dev eslint-plugin-mocha
```
	* you'll also need a few additional modules installed locally for the unit tests to run:
		* finally, install sinon and mocha-sinon locally for mocking `console.log` (these are for unit tests)
		* `npm install --save-dev sinon`
		* `npm install --save-dev mocha-sinon`
2. implement functions below in __hoffy.js__
3. make sure you export your functions as you implement them so that...
4. you can run tests as you develop these functions (again, the tests are included in the repository):
    `mocha tests/hoffy-test.js`
5. also remember to run eslint (there's a `.eslintrc` file included in the repository):
    `node_modules/.bin/eslint src/*`

### Functions to Implement

### (-2 per while, for, forEach, for of, or for in loop used)

<hr>

### `makeSet(num_1, num_2 to num_n)` (use appropriate syntax to accept any number of arguments)

__Parameters:__

* `num_1, num_2, ..., num_n` - the `Numbers` that need to be de-duplicated

__Returns:__

* an array of just the unique elements in `num_1` to `num_n`

__Description:__

A `Set` is a common data structure which only contains unique elements. In this problem, we want to convert any given series of numbers into a `Set`, this means we want to remove duplicates from the original incoming arguments and return as an `Array`. Assume than an empty `Array` or `Array` of `Number`s is passed in; no need to check types.

__Examples:__

```
    makeSet(1, 2, 2, 3, 1); // [1, 2, 3]
    makeSet(1, 2, 4, 3, 5); // [1, 2, 4, 3, 5]
    makeSet(1, 2, 4, 3, 2, 5, 3, 7, 2); // [1, 2, 4, 3, 5, 7]
```
__Hint:__

* Use `rest` parameters!

<hr>

### `findIndex(arr, num, compareFunc)`

__Parameters:__

* `arr` - an `Array`
* `num` - a value that we are looking for in the array 
* `compareFunc` - a function used to determine if an element in `arr` is the one that we're looking for
	* has two parameters, `value1` and `value2`
	* returns a boolean: `true` if both values should be treated as equal or `false` otherwise

__Returns:__

* an `Array` of all indices of `num` in the Array, `arr` [0 indexed]
* if the value is not in the `Array`, return `-1` in an array: `[-1]`

__Description__

Collects indices of every element in `arr` that returns `true` when passed into `compareFunc` along with `num`. Assume the appropriate types are passed in. No type checking is required.

__Examples:__

```
    findIndex([1, 2, 4, 3, 5], 2, (a, b) => a === b); // [1]
    findIndex([-3, -2, -1, 0, 1, 2, 4, 3, 5], 2, (a, b) => a === b || -a === b); // [1, 5]
    findIndex([1, 2, 4, 3, 5], 8, (a, b) => a === b); // [-1]
    findIndex([1, 2, 4, 3, 2, 5, 3, 7, 2], 2, (a, b) => a === b); // [1, 4, 8]
```

<hr>

### `filterWith(fn)`

__Parameters:__

* `fn` - a _callback_ function that takes in a single argument and returns a value (it will eventually operate on every element in an array)

__Returns:__

* `function` - a function that...
    * has 1 parameter, an `Array`
    * returns a new Array where only elements that cause `fn` to return `true` are present (all other elements from the old Array are not included)

__Description:__

This is different from regular filter. The regular version of filter immediately calls the callback function on every element in an Array to return a new Array of filtered elements. `filterWith`, on the other hand, gives back a function rather than executing the callback immediately (think of the difference between bind and call/apply). `filterWith` is basically a function that turns another function into a filtering function (a function that works on Arrays). 

__Example:__

    // original even function that works on Numbers
    function even(n) {return n % 2 === 0;} 

    // create a 'filter' version of the square function
    filterWithEven = filterWith(even); 

    // now square can work on Arrays of Numbers!
    console.log(filterWithEven([1, 2, 3, 4])); // [2, 4]    
    
    const nums = [1, NaN, 3, NaN, NaN, 6, 7];
    const filterNaN = filterWith(n => !isNaN(n));
    console.log(filterNaN(nums)); // [1, 3, 6, 7]

<hr>

### `intersection(arr1, arr2)`

__Parameters:__

* `arr1` - the first array containing `Numbers`
* `arr2` - the second array containing `Numbers`

__Returns:__

* an `Array` containing the elements found in both `arr1` and `arr2`
* if there are no common elements, return an empty array.

__Description:__

Finding intersection of lists of data is a very common problem in CS. We only want to store the common elements from both arrays. If there are duplicates in any of the array then make sure that the resulting array only contains one instance of it.

__Hint:__

Converting the arrays to `Sets` might be helpful.

__Examples:__

```
intersection([2], [2]); // [2]
intersection([2], [1]); // []
intersection([1, 2], [1]); // [1]
intersection([2, 1, 2], [1, 2]); // [1, 2]
```

<hr>

### `repeatCall(fn, n, arg)`

__Parameters:__

* `fn` - the function to be called repeatedly
* `n` - the number of times to call function, `fn`
* `arg` - the argument to be passed to `fn`, when it is called

__Returns:__

* `undefined` (no return value)

__Description:__

This function demonstrates using functions as an argument or arguments to another function. It calls function, `fn`, `n` times, passing in the argument, `arg` to each invocation / call. It will ignore the return value of function calls. Note that it passes in only one `arg`.

__Hint:__

Write a recursive function within your function defintion to implement repetition.

__Examples:__

```
repeatCall(console.log, 2, "Hello!");
// prints out:
// Hello!
// Hello!

// calls console.log twice, each time passing in only the first argument

repeatCall(console.log, 2, "foo", "bar", "baz", "qux", "quxx", "corge");
    
// prints out (again, only 1st arg is passed in):
// foo 
// foo 
```

<hr>

### `constrainDecorator(fn, min, max)`

__Parameters:__

* `fn` - the function to modify (_decorate_)
* `min` - the minimum value that `fn` can return
* `max` - the maximum value that `fn` can return

__Returns:__

* `function` - a function that...
    * does the same thing as the original function, `fn` (that is, it calls the original function)
    * accepts the same number of arguments as the original function, `fn`
    * the return value is the return value of `fn`, unless it is less than or greater than the `min` and `max`, in which case it returns `min` or `max` respectively

__Description:__

This function is a decorator. [See the slides on the decorator pattern](../slides/js/higher-order-functions-continued.html) for background information. It builds on top of the example in the slides by actually _modifying_ the return value of the original function.

This function wraps the function `fn` in another function so that operations can be performed before and after the original function `fn` is called. This can be used to modify incoming arguments, modify the return value, or do any other task before or after the function call. Again, we'll be modifying the return value in this case.

This particular decorator function constrains the result of the function being wrapped, `fn` so that its return value fits between `min` and `max` inclusive. If these are omitted from the original outer function, then the newly returned function will just return the value unmodified. You can assume that the return value of `fn` is `Number` (you do not have to deal with other types).


__Example:__

    // creates a new function from the built-in function, parseInt
    // the new function is the same thing as parseInt, but it constrains
    // the return value to a value between min and max (inclusive)
    const constrainedParseInt = constrainDecorator(parseInt, -10, 10);

    // still works like the original parseInt
    constrainedParseInt("7") // --> 7
    constrainedParseInt("-10")) // --> -10

    // but if the return value is less than min or greater than max
    // it returns min or max respectively
    constrainedParseInt("-12") // --> -10
    constrainedParseInt("12")) // --> 10

    // however, if either min or max are missing, then the new function
    // returns the result of fn unmodified regardless of value
    var constrainedParseInt2 = constrainDecorator(parseInt);
    constrainedParseInt2("-12") // --> -12

<hr>

### `limitCallsDecorator(fn, n)`

__Parameters:__

* `fn` - the function to modify (_decorate_)
* `n` - the number of times that `fn` is allowed to be called

__Returns:__

* `function` - a function that...
    * does the same thing as the original function, `fn` (that is, it calls the original function)
    * but can only be called `n` times
    * after the `n`th call, the original function, `fn` will not be called, and the return value will always be `undefined`

__Description:__

This is the culmination of all of the concepts from the previous functions. However, instead of just reading from a variable that's available through the closure, you'll use it to keep track of the number of times that a function is called... and prevent the function from being called again if it goes over the `max` number of allowed function calls. Here are the steps you'll go through to implement this:

1. create your decorator (function)
2. create a local variable to keep track of the number of calls
3. create an inner function to return
    * the inner function will check if the number of calls is less than the max number of allowed calls
    * if it's still under max, call the function, `fn` (allow all arguments to be passed), return the return value of calling `fn`, and increment the number of calls
    * if it's over max, just return `undefined` immediately without calling the original function

__Example:__

    const = limitedParseInt = limitCallsDecorator(parseInt, 3);
    limitedParseInt("423") // --> 423
    limitedParseInt("423") // --> 423
    limitedParseInt("423") // --> 423
    limitedParseInt("423") // --> undefined


<hr>


### `compose(fn1, fn2, ...,fnN)`

__Parameters:__

* `fn1, fn2, ..., fnN` - a bunch of functions

__Returns:__

* `function` - a function that will pass it's arguments to `fn1`, take the output of `fn1` and use it as the argument to `fn2`, then take the output of `fn2` and use it for `fn3`, and then... etc


__Description:__

A handy utility for automating the writing of code that's just calling functions to pass their arguments to other functions. You can assume that each function passed in only takes one argument.

HINT: we are _summing_ or _composing_ the functionality of a bunch of functions together

__Example:__


    // let's say you have some pretty procedural functions
    function superCamelCase(s) {
      return s
        .split("")
        .map((c, i) => (i % 2 == 0 ? c.toUpperCase() : c.toLowerCase()))
        .join("")
    }

    function spaceText(s) {
      return s.split("").join(" ")
    }

    function addStyle(s) {
      return "~~~ " + s + " ~~~"
    }

    // you want to make a playlist of them
    const aestheticFmtPipeline = compose(
      superCamelCase,
      spaceText,
      addStyle
    )

    console.log(aestheticFmtPipeline("hello world")) // ~~~ H e L l O   W o R l D ~~~

    function makeVertical(s) {
      return s.split("").join("\n")
    }

    // playlists of playlists of functions
    const tallAestheticFmt = compose(aestheticFmtPipeline, makeVertical)

    console.log(tallAestheticFmt("goodbye world"))
    /*
    ~
    ~
    ~

    G

    o

    O

    d

    B

    y

    E



    W

    o

    R

    l

    D

    ~
    ~
    ~
    */

### Test, Lint and Commit

Once you're finished with your functions, remember to:

1. make sure all tests are passing
2. make sure that eslint shows no errors
3. commit and push your code!

## Part 2 - Drawings and Classes


For this part of the homework, create classes in the file in your repository called __src/drawing.js__.



### SVG Overview

You'll be implementing classes that represent drawings / parts of a drawing by using SVG.

[SVG](https://developer.mozilla.org/en-US/docs/Web/SVG) is a markup language for creating vector graphics.

You can think of it as HTML for drawing! (Pssst... it's actually XML). So, some terms used to describe HTML and XML will describe SVG as well:

* __element__ - is a part of an SVG image; it's composed to tags, attributes and possibly text / content 
* __tag__ - is the name of an element surrounded by &lt; and &gt; `<rect>`; there can be opening and closing tags in an element: `<rect></rect>`
* __attribute__ - name and value pairs within an opening tag `<rect width="100">`
	* note that for the example above, the name is unquoted
	* and the value is quoted with double quotes
* __content__ - the text surrounded by tags: <text>this is content</text>

Elements can be nested within elements. For example: `<svg xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50"></rect> </svg>`

SVG markup can be placed in a `.svg` file. An `.svg` file can be opened with browsers, such as Chrome or Firefox. Some file explorers even render SVG directly. SVG can even be embedded directly in an html document (view source on this page, and search for `svg` tags.

### `svg` Element

The container (root element) for an SVG drawing is (big surprise) `svg`:

```
<svg xmlns="http://www.w3.org/2000/svg"> 
</svg>
```

* within this container, the x values increase from left to right.
* the y values increase from top to bottom

### `rect` Element

To draw a rectangle, use the `rect` element. Some attributes that you can define on a `rect` element are:

* `x` - the x location of the upper left corner of the rectangle
* `y` - the y location of the upper left corner of the rectangle
* `width` - the width in pixels of the rectangle
* `height` - the height in pixels of the rectangle
* `fill` - the fill color of the rectangle; this can be text, such as `"red"`, `"orange"`, etc. 

Note that the `rect` element can be self-closing, but for simplicity in our implementation, we'll create `rect` elements with both an opening and closing tag.

Here's an example of drawing two rectangles:

```
<rect x="25" y="50" width="50" height="100" fill="blue"></rect>
<rect x="35" y="20" width="50" height="100" fill="orange"></rect>
```

The code above results in this drawing:

<svg xmlns="http://www.w3.org/2000/svg">
<rect x="25" y="50" width="50" height="100" fill="blue"></rect>
<rect x="35" y="20" width="50" height="100" fill="orange"></rect>
</svg>

<br /> 

### `text` Element

The `text` element allows you to place text in your drawing. Some attributes include:

* `x` - the x location of the upper left corner of the text
* `y` - the y location of the upper left corner of the text
* `fill` - the fill color of the text; this can be a color name, such as `"red"`, `"orange"`, etc. 
* `font-size` - the size of the text

Note that the content of a text element (the value between the `text` tags) is what will be displayed. Here's an example:

```
<text x="50" y="70" fill="blue" font-size="70">SVG FTW!</text>
```

The code above results in the following drawing:

<svg xmlns="http://www.w3.org/2000/svg">
<text x="50" y="70" fill="blue" font-size="40">SVG FTW!</text>
</svg>

### Implementation 

You'll be creating classes that represent generic svg elements, `svg`, `rect`, and `text`. Your implementation:

* __does not require type checking of incoming arguments__ 
* __should not use__

* `while` loops
* `for` loops
* `for ... in` loops
* `for ... of` loops
* `forEach` method 

__There will a small (-2) penalty every time one is used__. (Homework is 100 points total)


Create these four classes in `src/drawing.js` __and export them__:

1. `GenericElement(name)` - represents a generic SVG element
	* `name` - the name of the element (this name is freeform, so, for example: `svg`, `rect`, or even an element that we haven't covered... `circle`)
2. `RootElement` - represents an `svg` element
	* should have the attribute: `xmlns="http://www.w3.org/2000/svg"` ...so that it is treated as a valid SVG (XML)
3. `RectangleElement` - represents a `rect` element
4. `TextElement` - represents a `text` element

Somewhere in these classes, you should define the following methods:

* `addAttr(name, value)` - adds an attribute named, `name` to the element called on, with value, `value`
	* `name` - the name of the attribute to be added
	* `value` - the value of the attribute to be added
* `addAttrs(obj)` - adds attributes (keeps existing attributes if already present, but if attribute names are the same, your discretion) to the element called on by using the property names and values of the object passed in: `{x: 100, y: 5}` would translate to `x="100" y="5"`
	* `obj` -  the object containing properties and value that will be used to create attributes and values on the element
* `addChild(child)` -  adds an element as a child to the element that this is called on (that is, `child`, is nested in this element
	* `child` - the element to be nested in the parent element
* `toString()` - returns the string representation of this element, including tags, attributes, text content, and nested elements... 
	* for example `'<svg xmlns="http://www.w3.org/2000/svg"><text x="50" y="70" fill="blue" font-size="40">SVG FTW!</text> </svg>'`
	* you can use any whitespace at your discretion (for example, you can add newlines if you want)
* `write(fileName, cb)` - write the string representation of your element and all its children to a file called `fileName`
	* `fileName` - the path of the file to write to
	* `cb` - function to call when writing is done
		* the callback function can have no parameters 
	* use [`fs.writeFile`](https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback) as part of your implementation

Your implementation must follow the requirements listed below:

* you must use `extends` for one or more of your classes
* you can add any properties necessary to make your code work
* an element's attributes can be in any order when the markup is generated (no specific ordering is required from your implementation)
* an element's children can be in any order when the markup is generated (no specific ordering is required from your implementation)
* you can place methods in whatever class you think is appropriate, and you can even repeat code (though you can use inheritance to prevent this) as long as your classes work with the following code:

```
const root = new RootElement();

const c = new GenericElement('circle');
c.addAttr('r', 75);
c.addAttr('fill', 'yellow');
c.addAttrs({'cx': 200, 'cy': 80});

root.addChild(c);

const r = new RectangleElement(0, 0, 200, 100, 'blue');
r.addAttrs({width: 800, height: 170});
root.addChild(r);

const t = new TextElement(50, 70, 70, 'red', 'wat is a prototype? 😬');
root.addChild(t);
console.log(root.toString());
root.write('test.svg', () => console.log('done writing!'));
```

The code above produces the markup below, either via printing to console by converting to a string with `toString` or by writing to a file: 

```
<svg xmlns="http://www.w3.org/2000/svg" width="800" height="170">
<circle r="75" fill="yellow" cx="200" cy="80">
</circle>
<rect x="0" y="0" width="200" height="100" fill="blue">
</rect>
<text x="50" y="70" fill="red" font-size="70">wat is a prototype? 😬
</text>
</svg>
```

Remember that in the resulting markup:

* spacing is at your discretion: you can add / remove newlines, for example
* an element's attributes can be in any order (your discretion)
* an element's children can be in any order (your discretion)

When opened with Chrome or Firefox, you should see:

<svg xmlns="http://www.w3.org/2000/svg" width="800" height="170">
<circle r="75" fill="yellow" cx="200" cy="80">
</circle>
<rect x="0" y="0" width="200" height="100" fill="blue">
</rect>
<text x="50" y="70" fill="red" font-size="70">wat is a prototype? 😬
</text>
</svg>

## Part 3 - Walt Disney Movies Data

### Overview

The original data was sourced from [https://www.kaggle.com/sooaaib/walt-disney-movies?select=disney_movies.json](https://www.kaggle.com/sooaaib/walt-disney-movies?select=disney_movies.json) which uses a Creative Commons license (## CC0 1.0 Universal  (CC0 1.0)  Public Domain Dedication). 

There are two steps to this part:

1. Implement helper functions in `disney.js`.
2. In `report.js`, use the functions implemented in `disney.js` to print a report.

### Examining the Data

* Assuming that your parsed JSON data is in a variable called `data` ...
* `data` will be an `Array` of _movie_ objects; each line should have been parsed from JSON before pushing into the `data` array ... ⚠️ there's no need to create a class representation of these objects
* Each movie object in `data` contains properties such as `title`, `Directed by`, etc.

For example, a single movie object in the  `data` array will have the following attributes:

```
{
    "title": "Cinderella",
    "Directed by": [
      "Clyde Geronimi",
      "Hamilton Luske",
      "Wilfred Jackson"
    ],
    "Produced by": "Walt Disney",
    "Story by": [
      "Ken Anderson",
      "Perce Pearce",
      "Homer Brightman",
      "Winston Hibler",
      "Bill Peet",
      "Erdman Penner",
      "Harry Reeves",
      "Joe Rinaldi",
      "Ted Sears",
      "Maurice Rapf (uncredited)"
    ],
    "Based on": [
      "Cinderella",
      "by",
      "Charles Perrault"
    ],
    "Starring": [
      "Ilene Woods",
      "Eleanor Audley",
      "Verna Felton",
      "Rhoda Williams",
      "James MacDonald",
      "Luis van Rooten",
      "Don Barclay",
      "Mike Douglas",
      "William Phipps",
      "Lucille Bliss"
    ],
    "Narrated by": "Betty Lou Gerson",
    "Music by": [
      "Oliver Wallace",
      "Paul J. Smith"
    ],
    "Edited by": "Donald Halliday",
    "Production company": "Walt Disney Productions",
    "Distributed by": "RKO Radio Pictures",
    "Release date": [
      "February 15, 1950 (Boston)",
      "March 4, 1950 (United States)"
    ],
    "Running time": "74 minutes",
    "Country": "United States",
    "Language": "English",
    "Budget": "$2.9 million",
    "Box office": "$263.6 million",
    "Running time (int)": 74,
    "Budget (float)": 2900000,
    "Box office (float)": 263600000.00000003,
    "Release date (datetime)": "February 15, 1950",
    "imdb_rating": "6.9",
    "imdb_votes": "156,720",
    "imdb_id": "tt1661199",
    "metascore": 69,
    "rotten_tomatoes": "84%"
  }
```

All of the functions in `disney.js` will work on a list of movie objects, with each object similar to the example above. This `Array` of movies will be used an argument (bound to the parameter, `data`) for most of the functions that you create.

Once you've implemented helper functions in `disney.js`, you can use these functions in your other file, `report.js`, to display some information. If it's helpful, you're free to to reuse functions from `hoffy.js` or `drawing.js` in this part (there's __no requirement to, however__, but `for`, `while`, `for in`, and `for of`, and `.forEach` are all still off limits.

`report.js` can be used as a command line utility. Given an absolute path to a json data file, It should examine the JSON file's contents and print out a report. The JSON file contains a list of movie objects.

Example usage:

```
# on the commandline
node src/report.js /absolute/path/to/your/repo/data/0021800952.json
```

```
The resulting output might look like this:

* The best movie by IMDB rating is: 'Pirates of the Caribbean: Dead Men Tell No Tales'.

* Movies starring Johnny Depp: ['Pirates of the Caribbean: Dead Men Tell No Tales', 'Pirates of the Caribbean: At World's End']

* Top 5 Critically acclaimed movies: [{"title":"Pirates of the Caribbean: Dead Men Tell No Tales'","metascore":92}, {"title":"Pirates of the Caribbean: At World's End'","metascore":95}]`

* Movies with rating greater than 9: `[{"title":"Pirates of the Caribbean: Dead Men Tell No Tales'","imdb_rating":92}, {"title":"Pirates of the Caribbean: At World's End'","imdb_rating":95}]`

* Percentage of movies with IMDB more than 9: 10%

* Most popular movies: ['Pirates of the Caribbean: Dead Men Tell No Tales', 'Pirates of the Caribbean: At World's End']

* Average IMDB Rating of all movies: 7

* Movie with longest running time: 'Pirates of the Caribbean: Dead Men Tell No Tales'.
```

The original `JSON` file will have to be parsed and manipulated so that it's in a data structure that you functions can work with.

### `disney.js` Functions

Again, each function will have a parameter, `data`, that's in the format of an `Array` of objects, with each object representing a movie.

1. `bestMovie(data)`
* **Parameters:**
*data* - an `Array` of objects, with each object representing a movie.
* **Returns:** a movie object representing the best movie
* **Description:** This function returns an _entire_ movie object that has the highest value for the `imdb_rating` property. If there's a tie, return an Array of movie objects 

2. `getMoviesByActor(data,actor_name)` *
* **Parameters:**
*data* - an `Array` of objects, with each object representing a movie.
*actor_name* - a `String` with the name of an actor.
* **Returns:** an `Array` of movie titles.
* **Description:** This function returns an `Array` containing the titles of the movies in a single `Array`. This can be retrieved from the `Starring` property (match actor_name with `Starring` property)
* For example, if actor_name is Johnny Depp, then the  `Array` returned could be:
	```["Pirates of the Caribbean: Dead Men Tell No Tales", "Pirates of the Caribbean: At World's End"]```

3. `listCriticallyAcclaimedMovies(data)`
* **Parameters:**
*data* - an `Array` of objects, with each object representing a movie.
* **Returns:** an `Array` containing the movie `title` and the `metascore`.
* **Description:** This function returns an `Array` of objects containing the movie `title` and the `metascore`.  Note: return movies with `rating` greater than 90.
* For example,
	```[
{"title":"Pirates of the Caribbean: Dead Men Tell No Tales'","metascore":92}, {"title":"Pirates of the Caribbean: At World's End'","metascore":95}
]```
4. `getAverageLength(data)`
* **Parameters:**
*data* - an `Array` of objects, with each object representing a movie.
* **Returns:** a `Number` representing the average length (runtime) of movies in the entire dataset; ignore movies without a length or non-numeric length; use the appropriate column that gives you a normalized value for length (the one that requires least clean-up)
* **Description:** This function  returns the average (runtime) of the entire dataset.


Export these functions using `module.exports`.

### `report.js`

In `report.js`:

1. bring in the functions from `disney.js`
	* feel free to add more helper functions / utilities
2. if useful, bring functions from `hoffy.js` 
3. use `process.argv[2]` to retrieve the path specified when `report.js` is run on the command line:
	* `node src/report.js /path/to/file`
	* `process.argv[2]` will contain `/path/to/file`
4. find a way to read the contents of this file, parse it, and transform the data into data that can be used for your `disney.js` functions
	* `JSON.parse` can be used to turn a string into a JavaScript object

5. print out a report that includes:

* The best movie by IMDB rating, title only
* Top 5 Critically acclaimed movies, as an `Array` of objects with movie title and meta
* Movies starring Johnny Depp, as an `Array` of titles only
* Average runtime of all movies 

Again, running the command (from the root of your project):

```
`node src/report.js /path/to/file`
```

Output should look _something_ like this:

```
* The best movie by IMDB rating is: 'Movie Title'.

* Top 5 Critically acclaimed movies: [{"title":"Movie 1'","metascore":92}, {"title":"Movie 2'","metascore":95}]`

* Movies starring Johnny Depp: ['Movie Title 1', 'Movie Title 2', 'etc.']

* Average running time: Number

```

Finally, in report.js, write out an svg barchart to a file called `chart.svg` that visualizes any aspect of the data set you'd like to explore. For example: the metascore for every movie in the "Cars" franchise or the top 3 movies with the highest budgets. __There are no restrictions for what loops in this part__. It'd be useful to use the `drawing.js` module you created, but you can also just hand construct the svg if you like.

Here's an example chart using hardcoded demo data:


<svg xmlns="http://www.w3.org/2000/svg">
<rect x="0" y="25" width="200" height="25" fill="green">
</rect>
<text x="210" y="45" fill="black" font-size="20">YES
</text>
<rect x="0" y="55" width="65" height="25" fill="green">
</rect>
<text x="70" y="75" fill="black" font-size="20">NO
</text>
<rect x="0" y="85" width="240" height="25" fill="green">
</rect>
<text x="250" y="105" fill="black" font-size="20">🤷‍♀️
</text>
</svg>

```
<svg xmlns="http://www.w3.org/2000/svg">
<rect x="0" y="25" width="200" height="25" fill="green">
</rect>
<text x="210" y="45" fill="black" font-size="20">YES
</text>
<rect x="0" y="55" width="65" height="25" fill="green">
</rect>
<text x="70" y="75" fill="black" font-size="20">NO
</text>
<rect x="0" y="85" width="240" height="25" fill="green">
</rect>
<text x="250" y="105" fill="black" font-size="20">🤷‍♀️
</text>
</svg>
```
Don't forget to lint, commit, and push your code!
</div>

</div>
